============================
KBUS talk for EuroPython2010
============================

:Author: Tony Ibbs
:Contact: tibs@tonyibbs.co.uk
:Date: July 2010

:Repository: http://code.google.com/p/kbus/

------------------------------------------------------------------------------

.. contents::

-----------------------------------------
How - A simple introduction to using KBUS
-----------------------------------------

Senders and Listeners
---------------------
This is intended as a very simple introduction to the basics of how to use
KBUS. The examples are not realistic, but should give some flavour of the
way that KBUS works.

We shall start with a single "actor" in our virtual playlet:

First our actor needs to connect to KBUS itself, by opening a Ksock:

.. [[[
    from rst_terminal import Terminal

    print "Introducing Rosencrantz"
    r = Terminal(1, "Rosencrantz")
    r.do("from kbus import Ksock",
         "rosencrantz = Ksock(0)",
         "print rosencrantz")
.. ]]]

The argument to Ksock is the number of the KBUS device to connect to. If KBUS
is installed, then device ``0`` will always exist, so it is a safe choice.

The default is to open the device for read and write - this makes sense since
we will want to write messages to it.

Once we've done that, we can try creating and sending a message:

.. [[[
    r.do("from kbus import Message",
         "ahem = Message('$.Actor.Speak', 'Ahem')",
         "rosencrantz.send_msg(ahem)")
.. ]]]

The call to Message creates a new message named ``$.Actor.Speak``, with the
message data ``"Ahem"``.

    *All message names are composed of a ``$`` followed by a series of
    dot-separated parts.*

    *Data doesn't have to be a string, it can be any sequence of bytes, but a
    simple string makes sense for these examples.*

The next line sends it. For convenience, the ``send_msg`` method also
returns the *message id* assigned to the message by KBUS - this can be used
to identify a specific message.

    *When a message is created by a user, it does not have a message id.*
   
    *When the KBUS kernel module makes its internal copy of the message, it
    assigns it a new message id, which uniquely identifies the message on this
    KBUS device. Basically, the second number in the id is incremented for
    each message.*

    *(Note this is not quite the whole story, as KBUS behaves differently if
    given a message that already has an id set, but that's for use with
    Limpets, which we'll ignore for now.)*

This will succeed, but doesn't do anything very useful, because no-one is
listening. So, we shall need a second process, which we shall start in a
new terminal.


.. [[[
    a = Terminal(2, "Audience")
    a.do("from kbus import *",
         "audience = Ksock(0)",
         "audience.bind('$.Actor.Speak')")
.. ]]]

I don't recommend using ``from`` thing ``import *``, but it does make
use at the prompt easier, and thus KBUS is designed to be safe for this
purpose.

Here, the audience has opened the same KBUS device (messages cannot be sent
between different KBUS devices). We've still opened it for
write, since they might, for instance, want to be able to send ``$.Applause``
messages later on. They've then 'bound to' the ``$.Actor.Speak`` message,
which means they will receive any messages that are sent with that name.

    (In fact, all messages with that name sent by anyone, not just by
    rosencrantz.)

Now, if Rosencrantz sends the message again, the audience can receive it.

.. [[[
    r.do("rosencrantz.send_msg(ahem)")
    a.do("audience.read_next_msg()")
.. ]]]

Note the new message has a new message id, and the message read by the
audience has the same message id - i.e., is the same message.

A friendlier representation of the message is given if one prints it:

.. [[[
    a.do("print _")
.. ]]]

"Plain" messages are termed "announcements", since they are just being
broadcast to whoever might be listening.

The message also indicates who it is from (in the ``from_`` field). This gives
the Ksock id of the Sender, which we can determine with:

.. [[[
    r.do("rosencrantz.ksock_id()")
.. ]]]

Since there was only one message sent, if the audience tries to listen again,
they're not going to "hear" anything new:

.. [[[
    a.do("print audience.read_next_msg()")
.. ]]]

We can set the audience to listening for messages as they arrive using
'select' in the traditional manner:

.. [[[
    a.do("import select",
          "while 1:",
          "  (r,w,x) = select.select([audience], [], [])",
          "  # At this point, r should contain audience",
          "  print audience.read_next_msg()",
          "")
.. ]]]

(although perhaps with more error checking, and maybe even a timeout, in a
real example).

So now if Rosencrantz speaks...

.. [[[
    r.do("rosencrantz.send_msg(Message('$.Actor.Speak', 'Hello there'))",
         "rosencrantz.send_msg(Message('$.Actor.Speak', 'Can you hear me?'))")
.. ]]]

...the audience should be able to hear him:

.. [[[
    a.show()
.. ]]]

Let's introduce another participant, also on the same KBUS device:

.. [[[
    g = Terminal(3, "Guildenstern")
    g.do("from kbus import *",
         "guildenstern = Ksock(0)",
         "print guildenstern")
.. ]]]

We can start them listening as well - this time using a wildcard.

.. [[[
    g.do("guildenstern.bind('$.Actor.*')")
.. ]]]

Guildenstern will hear any message whose name starts with the characters
``$.Actor.``.

In retrospect this makes sense for the audience, too - let's fix that.

.. [[[
    a.do("<CONTROL_C>",
        "audience.bind('$.Actor.*')",
         "while 1:",
         "  print audience.wait_for_msg()",
         "")
.. ]]]

For convenience, the KBUS Python binding provides the ``wait_for_msg`` method
to handle the simple form of ``select``.

It seems likely that rosencrantz will want to hear his colleague as well:

.. [[[
    r.do("rosencrantz.bind('$.Actor.*')")
.. ]]]

So now let guildenstern speak:

.. [[[
    g.do("guildenstern.send_msg(Message('$.Actor.Speak', 'Pssst!'))",
         "# Remember guildenstern is himself listening to '$.Actor.*'",
         "print guildenstern.read_next_msg()")
.. ]]]

and rosencrantz hears:

.. [[[
    r.do("msg = rosencrantz.read_next_msg()",
         "print msg")
.. ]]]

However, when we look to the audience, we see:

.. [[[
    a.show()
.. ]]]

This is because the audience has bound to the message twice - it is hearing it
once because it asked to receive every ``$.Actor.Speak`` message, and again
because it asked to hear any message matching ``$.Actor.*``.

The solution is simple - ask not to hear the more specific version.

.. [[[
    a.do("<CONTROL-C>",
         "audience.unbind('$.Actor.Speak')",
         "while 1:",
         "  msg = audience.wait_for_msg()",
         "  print msg",
         "")
.. ]]]

Note that the unbinding must match the binding exactly.

Requests and Repliers
---------------------
We've shown that KBUS allows one to "announce" (or, less politely,
"shout") messages, but KBUS also supports asking questions.

So let's make Guildenstern act as a Replier for "query" messages...

.. [[[
    g.do("guildenstern.bind('$.Actor.Ask.Guildenstern', True)")
.. ]]]

   *(Only one person may be bound as Replier for a particular message
   name at any one time, so that it is unambiguous who is expected to do
   the replying.*

   *Also, if a Sender tries to send a Request, but no-one has bound to that
   message name as a Replier, then an error is raised (contrast that with
   ordinary messages, where if no-one is listening, the message just gets
   ignored).)*

If Rosencrantz then sends a Request of that name:

.. [[[
    r.do("from kbus import Request",
         "req = Request('$.Actor.Ask.Guildenstern', 'Were you speaking to me?')",
         "rosencrantz.send_msg(req)")
.. ]]]

Remember, Rosencrantz still hears himself speaking - so let's undo that...

.. [[[
    r.do("print rosencrantz.read_next_msg()",
         "rosencrantz.unbind('$.Actor.*')")
.. ]]]

Guildenstern receives the request:

.. [[[
    g.do("req = guildenstern.read_next_msg()",
         "print req")
.. ]]]

The flags indicate that this message is a Request (``REQ``), and also that
this is a Request that guildenstern should reply to (``YOU``).

There's a convenience method to find out if a particular message needs a
reply:

.. [[[
    g.do("print req.wants_us_to_reply()")
.. ]]]

Of course, guildenstern also gets a copy of the message because of his binding
as a Listener to ``$.Actor.*``:

.. [[[
    g.do("msg = guildenstern.read_next_msg()",
         "print msg")
.. ]]]

This second copy of the message is still marked as a Request (``REQ``), but is
not marked as needing a reply (no ``YOU`` flag).

Incidentally, KBUS does guarantee that the Request marked for reply will
always be the first copy of the message to be received.

There is, in fact, a way to ask KBUS to only deliver one copy of messages with
a given name, the ``want_messages_once`` method, but I still have *some*
reservations about its use, and anyway, in this case it makes more sense for
Guildenstern just to unbind from ``$.Actor.*``.

.. [[[
    g.do("guildenstern.unbind('$.Actor.*')")
.. ]]]


Regardless, Guildenstern can then reply:

.. [[[
    g.do("rep = reply_to(req, 'Yes, yes I was')",
         "print rep",
         "guildenstern.send_msg(rep)",
         "guildenstern.read_next_msg()")
.. ]]]

The ``reply_to`` convenience function crafts a new ``Reply`` message, with the
various message parts set in an appropriate manner. And thus:

.. [[[
    r.do("rep = rosencrantz.read_next_msg()",
         "print rep")
.. ]]]

Note that Rosencrantz didn't need to be bound to this message to receive it -
he will always get a Reply to any Request he sends (KBUS goes to some lengths
to guarantee this, so that even if Guildenstern closes his Ksock, it will
generate a "gone away" message for him).

Of course, the audience was listening.

.. [[[
    a.show()
.. ]]]

Stateful requests
-----------------
Sometimes it is useful to accumulate state at one end of a conversation. In
such cases, the Sender wants to be sure that the same Replier is replying to
any Requests. If the original Replier unbinds, or even disconnects from the
Ksock, and someone else binds as Replier instead, that new someone will
clearly not have the requisite state, and thus the Sender would like to know
that this has occurred.

.. [[[
    r.do("# About to start tossing coins",
         "req = Request('$.Actor.Ask.Guildenstern',",
         "'Will you count heads for me?')",
         "rosencrantz.send_msg(req)")
.. ]]]

.. [[[
    g.do("req = guildenstern.read_next_msg()",
         "guildenstern.send_msg(reply_to(req, 'Yes, yes I shall'))",
         "guildenstern.bind('$.Actor.CoinToss', True)",
         "heads = 0",
         "while True:",
         "  toss = guildenstern.wait_for_msg()",
         "  print toss",
         "  if toss.data == 'Head':",
         "    print 'A head - amazing'",
         "    heads += 1",
         "  else:",
         "    print 'Bah, tails'",
         "  guildenstern.send_msg(reply_to(toss, 'Head count is %d'%heads))",
         "")
.. ]]]

.. [[[
    r.do("rep = rosencrantz.read_next_msg()",
         "print rep.from_",
         "# Throws a head",
         "from kbus import stateful_request",
         "sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "print sreq",
         "rosencrantz.send_msg(sreq)")
.. ]]]

The ``stateful_request`` is a convenience for preparing stateful request
messages based on an earlier Reply. It takes the ``from_`` field from the
Reply, and uses it as the ``to`` for the new Request. Having a specific ``to``
field is what makes the request stateful - sending it will fail if it is not
going to be delivered to exactly that Ksock id.

.. [[[
    g.show()
.. ]]]

The same again:

.. [[[
    r.do("count = rosencrantz.read_next_msg()",
         "print 'So,',count.data",
         "# Throws a head",
         "sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "rosencrantz.send_msg(sreq)")
.. ]]]

.. [[[
    g.show()
.. ]]]

Rosencrantz is good at throwing heads:

.. [[[
    r.do("count = rosencrantz.read_next_msg()",
         "print 'So,',count.data",
         "# Throws a head")
.. ]]]

But, aha, Falstaff intervenes, and forces Guildenstern to disconnect:

.. [[[
    g.do("<CONTROL-C>",
         "print 'Falstaff! No! Ouch!'",
         "guildenstern.close()")
.. ]]]

And Falstaff then binds as Replier to the ``CoinToss`` message name, in an
attempt to hijack the conversation - although, of course, he has no idea
of how many heads have been tossed, so would not actually be of any use in
this conversation:

.. [[[
    f = Terminal(4, "Falstaff")
    f.do("from kbus import *",
         "falstaff = Ksock(0)",
         "falstaff.bind('$.Actor.CoinToss', True)")
.. ]]]

Innocently, Rosencrantz continues, but since the intended recipient has gone
away, the message cannot be sent:

.. [[[
    r.do("sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "rosencrantz.send_msg(sreq)")
.. ]]]

And Rosencrantz discovers that, in fact, state has been lost, skulduggery has
been done, and so forth.

The Python interface is not terribly helpful with interpreting ``IOError``
error numbers, but there is a useful commandline utility that reports both the
standard Unix meaning of an ``errno``, and also the specfic KBUS meaning (as
given in the KBUS documentation). So, for instance:

::

  $ errno.py 32
  Error 32 (0x20) is EPIPE: Broken pipe

  KBUS:
  On attempting to send 'to' a specific replier, the replier with that id
  is no longer bound to the given message's name.

From the audience's point of view:

.. [[[
    a.show()
.. ]]]

Tidying up
----------

    *Just to show that these are real Python processes.*

And to end things...

.. [[[
    a.do("<CONTROL_C>",
         "exit()")
.. ]]]

Tidy everyone else up as well (showing that no-one has any messages left):

.. [[[
    r.do("for msg in rosencrantz:",
         "  print msg",
         "",
         "exit()")
    print
    g.do("exit()")
    print
    f.do("for msg in falstaff:",
         "  print msg",
         "",
         "exit()")
.. ]]]

Summary
-------
* To send or receive messages, a process opens a Ksock.
* A process can send messages (be a Sender).
* A process can bind to receive messages (be a Listener) by message name.
* When binding to a message name, wildcards can be used.
* When binding to a message name, a process can say it wants to receive
  Requests with that name (be a Replier)
* There can only be one Replier for a given message name.
* There can be any number of Listeners for a given message name.
* It is not an error to send an ordinary message if no-one is listening.
* It is an error to send a Request if there is no Replier.
* Stateful Reqests insist that the expected Replier is replying.

.. note:: Running the examples in this introduction requires having
   the KBUS kernel module installed. Typically, on Ubuntu, this means
   doing::

           svn checkout http://kbus.googlecode.com/svn/trunk/ kbus 
           cd kbus/kbus
           make
           sudo make rules
           sudo insmod kbus.ko

   When you've finished the examples, you can remove the kernel module again
   with::

             sudo rmmod kbus.ko

   The message ids shown in the examples are correct if you've just installed
   the kernel module - the second number in each message id will be different
   (although always ascending) otherwise.

--------------------------
Why - The reasons for KBUS
--------------------------

So why are we developing KBUS, rather than using some other messaging system?

Background
----------
I work for Kynesim (http://www.kynesim.co.uk) in Cambridge, UK.
We work primarily in the embedded world, particularly on Set-Top Boxes (STBs).
As such, typical software elements include video and audio decoders (or the
interfaces to them, if this is done by hardware), user interface via remote
control or keyboard, and some form of GUI, typically a web browser.

Clearly, some mechanism is required to provide communication between all of
these elements.

We have had experience of bad solutions in the past - their flaws include such
things as race conditions (for instance, when a browser crashes, it cannot
reliably resume communication with the other processes it needs to liaise
with), unreliable implementations (frustrating when one is not allowed to fix
them) and poor documentation (well, some of that was fixable).

Aims
----
We thus set out with the following aims for our solution:

* Simple models to "think with", so that we can have a well understood system.
* Predictable delivery.
* Reliability.
* *Always* get a reply to a request.
* Messages (on a particular bus) are in the same order for all recipients
  (deterministic message ordering per device).
* Small implementation size.
* Base code available in C (C++, for instance, is not always available on the
  platforms we work with).
* Good usability from Python (well, that was my requirement)
* We'd really prefer an open source package, and we definitely want one that
  is actively maintained.

and that didn't really seem to leave us with an option other than writing it
ourselves.

Simple models
-------------
Names for things
~~~~~~~~~~~~~~~~
We've striven for simple names for things:

* KBUS devices are the buses over which communication happens.

* Ksocks are the connections to those buses. The name is meant to suggest they
  are a bit like sockets, but not quite.

      (I'm not actually terribly happy with "Ksock", but it's difficult to
      come up with good names for things, and it's better than the working
      name of "Elephant" that I was using for a short while in early
      development.)

* The basic messaging entities are Senders, Listeners and Repliers - one
  should already be able to guess what they do.

* The basic types of messages are Announcements, Requests, Replies - again,
  these should be fairly obvious.

* Message names are defined fairly simply, with (we hope) just enough
  flexibility, and the parts of a message (``to`` and ``from``,
  ``in_reply_to``, etc.) are hopefully not too hard to understand from their
  names.

.. * I'm sorry about Limpets.

Interfaces
~~~~~~~~~~
There are three levels of interface provided:

1. The "bare Unix" level.

   We use a kernel module to provide our devices, which are named as
   ``/dev/kbus0`` (for bus 0), ``/dev/kbus1`` (for bus 1), and so on.
 
   Ksocks are then implemented with file operations - ``open``, ``read``,
   ``write``, ``close`` and IOCTLs), with which experienced Unix programmers
   should already be familiar,

2. The Python API. This was written as the primary testing API, and works with
   classes that match the main named things. I believe this to be fairly easy
   to use. I also use it as the main way of illustrating how KBUS works.

3. The C library. This hides the details of the "bare Unix" level, and also
   removes the worry about handling such things as ``ernno`` when using
   IOTCLs. It is intended to be the normal means of using KBUS from C, and
   should also be useful when writing interfaces in other languages (which can
   typically call C).

The KBUS kernel module
~~~~~~~~~~~~~~~~~~~~~~
Using a kernel module means that:

* We can have a file interface, which makes KBUS easier to use.
* We can expect a guarantee of being told when a Ksock has closed, including
  if it has been closed because the process that opened it has crashed. This
  type of guarantee is much harder to attain in user space.
* We can have a real expectation of our "daemon" not crashing (it is much
  easier to write a kernel module that is reliable, partly because there are
  so many constraints on how one does it, partly because one is executing in a
  different context, and partly because kernel mechanisms mediate the modules
  interaction with user space).
* We get to use relatively sophisticated and proven datastructures. Kernel
  modules are expected to use the provided mechanisms for handling lists
  and other datatypes. This avoids a lot of reinventing the wheel, or
  dependency on other libraries which might not be present.
* The kernel hides a lot of the complicated stuff (both at the top and bottom
  level) from us, so we can't do it wrong (well, it's much harder). For
  instance, ``read`` and ``write`` at the user level get filtered down into
  more predictable calls at the kernel module level.
* We benefit from kernel strategies on memory management, copying, etc.
* We stand to gain from the kernel handling such issues as multiple CPUs,
  threading and so on.
* With KBUS being in the kernel address space, we should benefit from less
  context switching.

Messages
~~~~~~~~
In order to keep KBUS itself simple, KBUS does not say anything about the
message content. It restricts itself to defining the message header and the
mechanisms for managing messages.

    (We do have a nearly finished ASN.1 library for message data, and are
    looking at XMPP support, but these will be extras, not core KBUS. And,
    of course, one can use other mechanisms as one wishes.)

As indicated in the section on naming, the fields in the header aim to be easy
to understand, and we try to define *just* the fields we need. Unused fields
are always zero.

Predictable delivery
--------------------
It is acceptable for a Listener to miss messages (although there are ways around
that), but a Replier shall never miss the Requests sent to it.

We also want to guarantee that each Request shall produce a Reply (even if it
is a Reply indicating failure to deliver the Request).

So:

* If a sender attempts to send a Request, but does not have room on its
  message queue for the (corresponding) Reply, then the message will not be
  sent, and the send will fail. At the "bare Unix" level, this means that the
  ``send`` IOCTL returns a ``-ENOLCK`` error - the failure is immediate.

* If a replier cannot receive a particular message, because its queue is full,
  then the message will not be sent, and the send will fail with a ``-EBUSY``
  error. Again, this failure is immediate.

* If a message has the ALL_OR_FAIL flag set, then a send will only succeed if
  the message could be added to all the (intended) recipient’s message
  queues (listeners as well).  Otherwise, ``send`` returns a ``-EBUSY``
  error. Again, failure is immediate.

* If a message has the ALL_OR_WAIT flag set, then a send will only succeed if
  the message could be added to all the (intended) recipient’s message
  queues (listeners as well).  Otherwise ``send`` returns a ``-EAGAIN`` error.
  Again, failure is immediate, and the sender then needs to discard the
  message, or play the ``poll``/``select`` game to wait for the send to
  finish).

Note that we believe these last two mechanisms are primarily of use when
debugging systems.

Finally:

    """KBUS guarantees that each Request will (eventually) be matched by a
    consequent Reply (or Status) message, and only one such."""

If the replier can't give a Reply, KBUS will generate one (e.g.,
"``$.KBUS.Replier.Unbound``" or "``$.KBUS.ReplierGoneAway``").

Message order is the same for all
---------------------------------
It is important that if sender R sends a message on a particular KBUS device,
and sender G sends a message on the same KBUS, then all recipients of both
messages will see them in the same order.

    (Imagine sending instructions to a video decoder and a video recorder.
    Clearly both may need to receive the same instructions, and it is
    important to receive the instructions in the appropriate order.

    Similarly, consider a logging Listener. This too clearly wants to receive
    messages in the same order as the other Listeners. It especially wants to
    see Requests and Replies in the appropriate order.)

Since KBUS (the kernel module) has control over both ends of the transactions,
this is fairly simple to guarantee.

Isolation of buses
------------------
KBUS can provide multiple KBUS devices, but it does not allow communication
between them; they are totally isolated from each other.

Think of our notional R and G as metaphorical goldfish in a bowl.
They can only communicate via KBUS, and each bowl contains a single KBUS
device - in this instance, KBUS device 3:

.. image:: images/04_fish_in_bowl2.png
   :width: 5cm

.. :width:  370px
.. :height: 306px
.. :scale:  66

Two other fish, communicating via a different KBUS device, are in a different
metaphorical bowl, and thus cannot communicate with R and G.

.. image:: images/09_two_disjoint_bowls.png
   :width: 10.3cm

*(but, limpets...)*

Documentation
-------------
It didn't make the list of "Aims", because I just assumed it as a necessary
part of *any* project, but KBUS also comes with documentation. Indeed, the
initial documentation came before the first implementation.

Particularly in the first phases of development, we would cycle through:

* Describe how features of KBUS should (probably) work
* Look at implementing (the next part of) that
* Discover whether it made sense
* Refine documentation or implementation, as appropriate

Sometimes following through the logic of the specification in the
documentation would lead to inconsistencies (so let's not do it like that,
then), and sometimes doing the actual implenentation would lead to "ah, in
that case" moments, feeding back into the documentation.

Reading "Coder at Work", by Peter Seibel, I was struck by the following, which
feels somewhat similar:

  """We met every morning at coffee and had a long conversation -- about an
  hour to two hours -- and we covered the whiteboard in stuff. I'd take loads
  of notes -- I wrote all the documentation immediately and they wrote all the
  code. Sometimes I'd write a bit of code as well. And when I was writing the
  documentation I'd discover, I can't describe this, we have to change it. Or
  they would run into me and say, "Nah, it doesn't work; this idea we had this
  morning, because of this, this, this, and this it doesn't work." At the end
  of the day we either got to the point where we got all the documentation and
  all the code or enough of the code and enough of the documentation that we
  knew it was going to work. And then we called it a day."""

  -- Joe Armstrong (Erlang), on designing and writing OTP (Open Telecom Platform,
  "a middleware platform for building high availability, fault tolerant,
  distributed, soft real-time systems" -- sort of a .NET for Erlang), page
  230.

Being able to produce quick examples with the Python binding was especially
important for this process - a flavour of how a feature would work (or not)
could be gotten as soon as something was being implemented.

Why not use?
------------
What else could we have used?

POSIX message queues
~~~~~~~~~~~~~~~~~~~~
Linux systems provide POSIX message queues, via the ``mqueue`` system. This
was not present before 2.6.2, which is one reason I didn't consider it(!). It
apears to be intended for use in realtime systems, where message sending needs
to be fast, but there are not large numbers of messages.

*Provide some more information, based on the man pages...*

DBUS
~~~~
I've not spent an awful lot of time looking at DBUS, but my initial thoughts
are that:

* I don't understand it. Its documentation seems to show an over complex
  model, with no quick way in to understanding it, and a wish to split things
  into as many levels as possible.
* It is socket oriented (not a kernel module), which is probably the best
  approach for a user-space daemon, but
* It is in user-space, with the problems that can entail (including the
  difficulty of detecting if a replier has closed/crashed)
* Perhaps most importantly, it doesn't preserve message ordering across the
  bus. This is one of our key requirements.

    (My other note says "can't have more than one connection to the same dbus,
    and thus cannot get message ordering" - this sounds a key problem, if
    true.)

* I am told it is not all reliable...
* ...or even all implemented
* It is large.

But it is widely used (hmm) and has been around quite a while.

zeromq / 0mq
~~~~~~~~~~~~
zeromq (or 0mq) looks rather nice. It has good introductions, and seems to
have a clear idea of what its aims are, in particular aiming for speed
and scalability.

Its messages are minimalistic in strucure (a name and then content), which is
really rather nice. It is also very cross platform, both in the "implemented
on" sense, and in the "available for language X" sense.

It doesn't appear to b e aiming for the sort of "predicability" we're after
(or so I deduce from a scan of the documentation). And it is written in C++,
which rules it out for some prospective platforms.

However, this looks like one it would be fun to play with, and I definitely need to
learn more about it.

  (It's very tempting to think about it as a potential means of moving KBUS
  messages over networks, for instance.)

What else?
~~~~~~~~~~
I must have missed systems that I really should know about.

(Although note I'm ignoring many "enterprise space" systems, which often do
seek guarantees of delivery, but at the cost of being an enterprise system.)

----------------
Example messages
----------------
Some actual example message names, from Real Applications (lightly obfuscated,
perhaps).

...EXAMPLES TO BE INSERTED...

Maybe mention:

1. C++ bindings - I don't have the experience in C++ to write well designed
   bindings. Either use the C API, or talk directly on the file interface.
   If someone wants to contribute one...

2. JavaScript - we do have bindings for V8 (for a customer), but obviously
   each JavaScript implementation needs to have its own implementation. Talk
   to us if this is of interest...

3. Other languages - either the C API or the direct approach should serve as a
   starting point. Perhaps OO bindings can look at what I've done for Python.

-------
Limpets
-------
The problem, in brief
---------------------
By design, KBUS does not allow message sending between KBUS devices.

Also, KBUS the-kernel-module only provides message sending on a single
machine.

In the KBUS tradition of trying to provide simple, but just sufficient,
solutions, KBUS Limpets allow intercommunication between pairs of KBUS
devices, possibly on different machines.

Summary
-------
A Limpet proxies KBUS message between a KBUS device and another Limpet.

Thus one has a connection something like::

    KBUS<x> <----> L<x> : L<y> <----> KBUS<y>

The paired Limpets communicate via a socket.

To someone talking to KBUS<x>, it should appear as if messages to/from someone
using KBUS<y> are sent/received directly. In particular, Requests and Replies
(including Stateful Requests) are proxied transparently.

Restrictions and caveats
------------------------
There are various restrictions on what Limpets can do and how they must be
used. These are mostly intrinsic in the approach taken, and avoiding them
would require doing something more sophisticated.

* The name is unintuitive. Sorry.

* All Limpets that can be reached by a message must have distinct network ids.

      Limpet network ids are used to identify the Limpet's pair, and also
      for determining if a message has originated with this particular Limpet.
      If the network ids are not unique, this will go horribly wrong.

* Limpets do not support closed loops. Thus the "network" formed by Limpets
  and KBUS devices must be "open" - for instance, a tree structure or star.

      If a loop is formed in the network, messages may go round and round
      forever. And other bad stuff.

* When starting up a Limpet pair, one must be designated the server and the
  other the client (in the traditional socket handling manner). This is a
  nuisance, but doing otherwise would be more complex, and possibly
  unreliable.

* Don't connect both ends of a Limpet pair to the same KBUS device. Just
  don't.

* Limpets intrinsically assume a "safe" network, i.e., there is no way of
  "proving" that the end of a message passing chain is a proper Limpet, rather
  than someone spoofing one.

      In particular, if we have a chain (e.g., x->K1->L1:L2->K2->L3:L4->K3->y) and
      are passing through a Stateful Request, L2 has to trust that the Replier
      for the message on K2 is actually a Limpet who is going to pass the
      message on (ultimately to y). The message is only marked with who it was
      originally from (x) and who it is aimed at (y), and if L3 is not
      actually a Limpet (but someone who has taken its place), there is little
      that we can do about it.

* KBUS itself is intended to give a very good guarantee that a Request will
  always generate a Reply (of some sort). Whilst the Limpet system tries to
  provide a reasonably reliable mechanism, there is no way that it can be as
  robust in this matter as just talking to a KBUS device.

* Limpets default to proxying "$.*" (i.e., all messages). It is possible to
  proxy something different, but this is untested, and actually of unproven
  utility (I just had a feeling it might be useful). So if you try, cross your
  fingers and let me know the results.

* It *is* possible to tell if a message is going through Limpets, by
  inspection of the message id (the network id will be set when it is
  intermediate networks), and the use of the "originally from" and "finally
  to" fields. Thus the use of Limpets is not strictly transparent.

  Also, there are some specialised messages returned only by Limpets.

  I do not believe this to be a problem. It may possibly be an advantage.

* The most important problem with Limpets is that they are not (at the moment)
  particularly well tested. Although I've done a fair amount of paper-and-pen
  figuring of message/KBUS/Limpet interaction, and some testing, it is still
  possible that I've missed a whole chunk of necessary functionality. So
  please treat the whole thing as heavily ALPHA for the moment.

Note that KBUS does not provided the full implementation necessary for Limpets
- what it provides is the KBUS-related infrastructure necessary to do the
KBUS<->Limpet communications.

With goldfish bowls
-------------------
Consider a particular machine as a goldfish bowl. Inside is a KBUS kernel
module, and the contents of the bowl communicate with this (and thus each
other) in the normal KBUS manner.

.. image:: images/05_fish_talk.png
   :width: 5cm

..   :width:  370px
..   :height: 306px
..   :scale:  66

Now consider another goldfish bowl. We'd like to be able to make the two KBUS
kernel modles (one in each) communicate.

So, let's place a limpet on the inside of each bowl's glass. Each limpet can
communicate with the other using a simple laser communications link (so
they're clever cyborg limpets), and each limpet can also communicate with its
KBUS kernel module.

.. image:: images/06_limpet_pair.png
   :width: 10.3cm

..   :width:  787px
..   :height: 306px
..   :scale:  66

So the Limpet needs to proxy things for KBUS users in its bowl to the other
bowl, and back again.

So if goldfish G in Bowl 3 wants to bind as a listener to message ``$.Gulp``,
then we want the Limpet in Bowl 0 to forward all ``$.Gulp`` messages from its
KBUS kernel module, and the Limpet in Bowl 3 then needs to echo them to the
KBUS kernel module in its bowl. So when goldfish A sends a ``$.Gulp`` message,
goldfish G will hear it:

.. image:: images/07_A_talks_to_G.png
   :width: 10.3cm

..   :width:  787px
..   :height: 307px
..   :scale:  66

What if goldfish G wants to bind as a Replier for message ``$.Gulp``? Limpets
handle that as well, by binding as a proxy-replier in the other goldfish
bowls.

So:

* Goldfish G binds as a replier for ``$.Gulp``.
* KBUS device 3 sends out a Replier Bind Event message, saying that goldfish G
  has bound as a replier for ``$.Gulp``.
* Limpet 2 receives this message, and tells Limpet 1.
* Limpet 1 binds as a replier for ``$.Gulp``, on KBUS device 0.

This allows goldfish A and G to interact with a Request/Reply sequence as
normal:

* Goldfish A send a request ``$.Gulp``.
* Limpet 1 receives it, as the Replier for that message on KBUS device 0.
* Limpet 1 sends the message to Limpet 2.
* Limpet 2 sends the message, as a Request, to KBUS device 3.
* Goldfish G receives the message, marked as a Request to which it should
  reply.
* Goldfish G replies to the request.
* Limpet 2 receives the reply (since it issued the request on this KBUS
  device).
* Limpet 2 sends the message to Limpet 1.
* Limpet 1 uses the message to form *its* reply, which it then sends to
  KBUS device 0, since in this bowl *it* is the replier.
* Goldfish A receives the reply.

Handling Stateful Requests (and Replies) needs a bit more infrastructure, but
is essentially handled by the same mechanism, although we need to show it in a
bit more detail this time.

    (Stateful transactions use the message header ``orig_from`` and
    ``final_to`` fields. When a message is sent through a Limpet, the
    ``orig_from`` indicates both the original Ksock (goldfish G) and also
    the first Limpet (Limpet 2). This can then be copied to the ``final_to``
    field of a Stateful Request to indicate that it really is goldfish G that
    is wanted, even though goldfish A can't "see" them.)

These mechanisms will also work when there are intermediate bowls:

.. image:: images/08_3_bowls.png
   :width: 15cm

..   :width:  790px
..   :height: 210px

.. vim: set filetype=rst tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
