============================
KBUS talk for EuroPython2010
============================

Tony Ibbs, tibs@tonyibbs.co.uk

http://code.google.com/p/kbus/

------------------------------------------------------------------------------

1. How to use KBUS
2. Why we wanted it

Maybe some other bits...

-----------------------------------------
How - A simple introduction to using KBUS
-----------------------------------------

This is intended as a very simple introduction to the basics of how to use
KBUS. The examples are not realistic, but should give some flavour of the
way that KBUS works.

We shall start with a single "actor" in our virtual playlet:

First our actor needs to connect to KBUS itself, by opening a Ksock:

.. [[[
    from rst_terminal import Terminal

    print "Introducing Rosencrantz"
    r = Terminal(1, "Rosencrantz")
    r.do("from kbus import Ksock",
         "rosencrantz = Ksock(0)",
         "print rosencrantz")
.. ]]]

This specifies which KBUS device to connect to. If KBUS is installed, then
device ``0`` will always exist, so it is a safe choice. The default is to open
the device for read and write - this makes sense since we will want to write
messages to it.

Once we've done that, we can try sending a message:

.. [[[
    r.do("from kbus import Message",
         "ahem = Message('$.Actor.Speak', 'Ahem')",
         "rosencrantz.send_msg(ahem)")
.. ]]]

The first line creates a new message named ``$.Actor.Speak``, with the
message data ``"Ahem"``.

    *(All message names are composed of ``$`` followed by a series of
    dot-separated parts.)*

The second line sends it. For convenience, the ``send_msg`` method also
returns the *message id* assigned to the message by KBUS - this can be used
to identify a specific message.

    *(When a message is created by a user, it does not have a message
    id. When it is sent, the KBUS kernel module assigns it a message id,
    which uniquely identifies the message on this KBUS device. Message
    ids are unique, and the second number in the id is incremented for
    each message.)*

    *(Note this is not quite the whole story, as if there already was a
    message id it won't be changed, but that's for other purposes.)*

This will succeed, but doesn't do anything very useful, because no-one is
listening. So, we shall need a second process, which we shall start in a
new terminal.


.. [[[
    a = Terminal(2, "Audience")
    a.do("from kbus import *",
         "audience = Ksock(0)",
         "audience.bind('$.Actor.Speak')")
.. ]]]

I don't recommend using ``from`` thing ``import *``, but it does make
use at the prompt easier, and thus KBUS is designed to be safe for this
purpose.

Here, the audience has opened the same KBUS device (messages cannot be sent
between different KBUS devices). We've still opened it for
write, since they might, for instance, want to be able to send ``$.Applause``
messages later on. They've then 'bound to' the ``$.Actor.Speak`` message,
which means they will receive any messages that are sent with that name.

    (In fact, all messages with that name sent by anyone, not just by
    rosencrantz.)

Now, if Rosencrantz sends the message again, the audience can receive it.

.. [[[
    r.do("rosencrantz.send_msg(ahem)")
    a.do("audience.read_next_msg()")
.. ]]]

Note the new message has a new message id, and the message read by the
audience has the same message id - i.e., is the same message.

A friendlier representation of the message is given if one prints it:

.. [[[
    a.do("print _")
.. ]]]

"Plain" messages are termed "announcements", since they are just being
broadcast to whoever might be listening.

The message received has the same ``MessageId`` as the message sent (which is
good!).

Each Ksock connection has an id associated with it - for instance:

.. [[[
    r.do("rosencrantz.ksock_id()")
.. ]]]

And the message also indicates who sent it (the ``from`` field).

.. [[[
    a.do("print _")
.. ]]]

Of course, if the audience tries to listen again, they're not going to "hear"
anything new:

.. [[[
    a.do("print audience.read_next_msg()")
.. ]]]

We can set the audience to listening for messages as they arrive using
'select'

.. [[[
    a.do("import select",
          "while 1:",
          "   (r,w,x) = select.select([audience], [], [])",
          "   # At this point, r should contain audience",
          "   print audience.read_next_msg()",
          "")
.. ]]]

  (although perhaps with more error checking, and maybe even a timeout, in a
  real example).

So now if Rosencrantz speaks...

.. [[[
    r.do("rosencrantz.send_msg(Message('$.Actor.Speak', 'Hello there'))",
         "rosencrantz.send_msg(Message('$.Actor.Speak', 'Can you hear me?'))")
.. ]]]

...the audience should be able to hear him:

.. [[[
    a.show()
.. ]]]

Let's introduce another participant, also on the same KBUS device:

.. [[[
    g = Terminal(3, "Guildenstern")
    g.do("from kbus import *",
         "guildenstern = Ksock(0)",
         "print guildenstern")
.. ]]]

who also starts listening - this time using a wildcard. This listener will
hear any message whose name starts with ``$.Actor.``.

.. [[[
    g.do("guildenstern.bind('$.Actor.*')")
.. ]]]

In retrospect this makes sense for the audience, too - let's fix that.
For convenience, the KBUS Python binding provides a useful method to handle
our ``select``:

.. [[[
    a.do("<CONTROL_C>",
        "audience.bind('$.Actor.*')",
         "while 1:",
         "   print audience.wait_for_msg()",
         "")
.. ]]]

It seems likely that rosencrantz will want to hear his colleague as well:

.. [[[
    r.do("rosencrantz.bind('$.Actor.*')")
.. ]]]

So let guildenstern speak:

.. [[[
    g.do("guildenstern.send_msg(Message('$.Actor.Speak', 'Pssst!'))",
         "# Remember guildenstern is himself listening to '$.Actor.*'",
         "print guildenstern.read_next_msg()")
.. ]]]

and rosencrantz hears:

.. [[[
    r.do("msg = rosencrantz.read_next_msg()",
         "print msg")
.. ]]]

However, when we look to the audience, we see:

.. [[[
    a.show()
.. ]]]

This is because the audience has bound to the message twice - it is hearing it
once because it asked to receive every ``$.Actor.Speak`` message, and again
because it asked to hear any message matching ``$.Actor.*``.

The solution is simple - ask not to hear the more specific version.

Note that an unbinding must match the binding exactly.

.. [[[
    a.do("<CONTROL-C>",
         "audience.unbind('$.Actor.Speak')",
         "while 1:",
         "   msg = audience.wait_for_msg()",
         "   print msg",
         "")
.. ]]]

We've shown that KBUS allows one to "announce" (or, less politely,
"shout") messages, but KBUS also supports asking questions.

So let's make Guildenstern listen to "Speak" messages, and act as a
Replier for "query" messages...

.. [[[
    g.do("guildenstern.unbind('$.Actor.*')",
         "guildenstern.bind('$.Actor.Speak')",
         "guildenstern.bind('$.Actor.Ask.Guildenstern', True)")
.. ]]]

   *(Only one person may be bound as Replier for a particular message
   name at any one time, so that it is unambiguous who is expected to do
   the replying.*

   *Also, if a Sender tries to send a Request, but no-one has bound to that
   message name as a Replier, then an error is raised (contrast that with
   ordinary messages, where if no-one is listening, the message just gets
   ignored).)*

If Rosencrantz then sends a Request of that name:

.. [[[
    r.do("from kbus import Request",
         "req = Request('$.Actor.Ask.Guildenstern', 'Were you speaking to me?')",
         "rosencrantz.send_msg(req)")
.. ]]]

Remember, Rosencrantz still hears himself speaking - so let's undo that...

.. [[[
    r.do("print rosencrantz.read_next_msg()",
         "rosencrantz.unbind('$.Actor.*')")
.. ]]]

Guildenstern receives the request:

.. [[[
    g.do("req = guildenstern.read_next_msg()",
         "print req")
.. ]]]

The flags indicate that this message is a Request (``REQ``), and also that
this is a Request that guildenstern should reply to (``YOU``).

There's a convenience method to find out if a particular message needs a
reply:

.. [[[
    g.do("print req.wants_us_to_reply()")
.. ]]]

Of course, guildenstern also gets a copy of the message because of his binding
as a Listener to ``$.Actor.*``:

.. [[[
    g.do("msg = guildenstern.read_next_msg()",
         "print msg")
.. ]]]

This second copy of the message is still marked as a Request (``REQ``), but is
not marked as needing a reply (no ``YOU`` flag).

Incidentally, KBUS does guarantee that the Request marked for reply will
always be the first copy of the message to be received.

*(There is, in fact, a way to ask KBUS to only deliver one copy of
a given message, and if guildenstern had used that, he would only have
received the Request that was marked for him to answer. I'm still a little
undecided how often this mechanism should be used, though.)*

Guildenstern can then reply:

.. [[[
    g.do("rep = reply_to(req, 'Yes, yes I was')",
         "print rep",
         "guildenstern.send_msg(rep)",
         "guildenstern.read_next_msg()")
.. ]]]

The ``reply_to`` convenience function crafts a new ``Reply`` message, with the
various message parts set in an appropriate manner. And thus:

.. [[[
    r.do("rep = rosencrantz.read_next_msg()",
         "print rep")
.. ]]]

Note that Rosencrantz didn't need to be bound to this message to receive it -
he will always get a Reply to any Request he sends (KBUS goes to some lengths
to guarantee this, so that even if Guildenstern closes his Ksock, it will
generate a "gone away" message for him).

Of course, the audience was listening.

.. [[[
    a.show()
.. ]]]

-------------------------------------------------------------------------------

Stateful transactions - explanations to be added later.

.. [[[
    r.do("# About to start tossing coins",
         "req = rosencrantz.send_msg(Request('$.Actor.Ask.Guildenstern',",
         "'Will you count heads for me?'))")
.. ]]]

.. [[[
    g.do("req = guildenstern.read_next_msg()",
         "guildenstern.send_msg(reply_to(req, 'Yes, yes I shall'))",
         "guildenstern.bind('$.Actor.CoinToss', True)",
         "heads = 0")
.. ]]]

.. [[[
    r.do("rep = rosencrantz.read_next_msg()",
         "print rep.from_",
         "# Throws a head",
         "from kbus import stateful_request",
         "sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "rosencrantz.send_msg(sreq)")
.. ]]]

.. [[[
    g.do("while True:",
         "    toss = guildenstern.wait_for_msg()",
         "    if toss.data == 'Head':",
         "       print 'A head - amazing'",
         "       heads += 1",
         "    else:",
         "       print 'Bah, tails'",
         "    guildenstern.send_msg(reply_to(toss, 'Head count is %d'%heads))",
         "")
.. ]]]

.. [[[
    r.do("count = rosencrantz.read_next_msg()",
         "print 'So,',count.data",
         "# Throws a head",
         "sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "rosencrantz.send_msg(sreq)")
.. ]]]

The same again:

.. [[[
    g.show()
.. ]]]

Rosencrantz is good at throwing heads:

.. [[[
    r.do("count = rosencrantz.read_next_msg()",
         "print 'So,',count.data",
         "# Throws a head")
.. ]]]

But, aha, Falstaff intervenes, and forces Guildenstern to disconnect:

.. [[[
    g.do("<CONTROL-C>",
         "print 'Ouch'",
         "guildenstern.close()")
.. ]]]

And attempts to hijack the conversation - although, of course, he has no idea
of how many heads have been tossed, so would not actually be of any use:

.. [[[
    f = Terminal(4, "Falstaff")
    f.do("from kbus import *",
         "falstaff = Ksock(0)",
         "falstaff.bind('$.Actor.CoinToss', True)")
.. ]]]

Innocently, Rosencrantz continues:

.. [[[
    r.do("sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "rosencrantz.send_msg(sreq)")
.. ]]]

And discovers that, in fact, state has been lost, skulduggery has been done,
and so forth.

::

  $ errno.py 32
  Error 32 (0x20) is EPIPE: Broken pipe

  KBUS:
  On attempting to send 'to' a specific replier, the replier with that id
  is no longer bound to the given message's name.

From the audience's point of view:

.. [[[
    a.show()
.. ]]]

-------------------------------------------------------------------------------

And to end things...

.. [[[
    a.do("<CONTROL_C>",
         "exit()")
.. ]]]

Tidy everyone else up as well (showing that no-one has any messages left):

.. [[[
    r.do("for msg in rosencrantz:",
         "    print msg",
         "",
         "exit()")
    print
    g.do("exit()")
    print
    f.do("for msg in falstaff:",
         "    print msg",
         "",
         "exit()")
.. ]]]

-------------------------------------------------------------------------------

So, in summary:

* To send or receive messages, a process opens a Ksock.
* A process can send messages (be a Sender).
* A process can bind to receive messages (be a Listener) by message name.
* When binding to a message name, wildcards can be used.
* When binding to a message name, a process can say it wants to receive
  Requests with that name (be a Replier)
* It is not an error to send an ordinary message if no-one is listening.
* It is an error to send a Request if there is no Replier.
* There can only be one Replier for a given message name.
* There can be any number of Listeners for a given message name.
* Stateful Reqests insist that the expected Replier is replying.

.. note:: Running the examples in this introduction requires having
   the KBUS kernel module installed. If this is not already done, and you have
   the KBUS sources, then ``cd`` to the kernel module directory (i.e.,
   ``kbus`` in the sources) and do::

             make
             make rules
             sudo insmod kbus.ko

   When you've finished the examples, you can remove the kernel module again
   with::

             sudo rmmod kbus.ko

   The message ids shown in the examples are correct if you've just installed
   the kernel module - the second number in each message id will be different
   (although always ascending) otherwise.

---
Why
---

.. Taken from the Kynesim blog post

So why are we developing KBUS, rather than using some other messaging system?

  (I'm going to assume you've seen the previous blog items on KBUS, and/or
  read the KBUS documentation on its Google code page.)

.. more

Our background
--------------
We work primarily in the embedded world, particularly on Set-Top Boxes (STBs).
As such, typical software elements include video and audio decoders (or the
interfaces to them, if this is done by hardware), user interface via remote
control or keyboard, and some form of GUI, typically a web browser.

Clearly, some mechanism is required to provide communication between all of
these elements.

We have had experience of bad solutions in the past - their flaws include such
things as race conditions (for instance, when a browser crashes, it cannot
reliably resume communication with the other processes it needs to liaise
with), unreliable implementations (frustrating when one is not allowed to fix
them) and poor documentation (well, some of that was fixable).

Aims
----
We thus set out with the following aims for our solution:

* Simple models to "think with", so that we can have a well understood system.
* Predictable delivery.
* Reliability.
* *Always* get a reply to a request.
* Messages (on a particular bus) are in the same order for all recipients
  (deterministic message ordering per device).
* Small implementation size.
* Base code available in C (C++, for instance, is not always available on the
  platforms we work with).
* Good usability from Python (well, that was my requirement)
* We'd really prefer an open source package, and we definitely want one that
  is actively maintained.

and that didn't really seem to leave us with an option other than writing it
ourselves.

Simple models
-------------
Names for things
~~~~~~~~~~~~~~~~
We've striven for simple names for things:

* KBUS devices are the buses over which communication happens.

* Ksocks are the connections to those buses. The name is meant to suggest they
  are a bit like sockets, but not quite.

      (I'm not actually terribly happy with "Ksock", but it's difficult to
      come up with good names for things, and it's better than the working
      name of "Elephant" that I was using for a short while in early
      development.)

* The basic messaging entities are Senders, Listeners and Repliers - one
  should already be able to guess what they do.

* The basic types of messages are Announcements, Requests, Replies - again,
  these should be fairly obvious.

* Message names are defined fairly simply, with (we hope) just enough
  flexibility, and the parts of a message (``to`` and ``from``,
  ``in_reply_to``, etc.) are hopefully not too hard to understand from their
  names.

* I'm sorry about Limpets.

Interfaces
~~~~~~~~~~
There are three levels of interface provided:

1. The "bare Unix" level.

   We use a kernel module to provide our devices, which are named as
   ``/dev/kbus0`` (for bus 0), ``/dev/kbus1`` (for bus 1), and so on.
 
   Ksocks are then implemented with file operations - ``open``, ``read``,
   ``write``, ``close`` and IOCTLs), with which experienced Unix programmers
   should already be familiar,

2. The Python API. This was written as the primary testing API, and works with
   classes that match the main named things. I believe this to be fairly easy
   to use. I also use it as the main way of illustrating how KBUS works.

3. The C library. This hides the details of the "bare Unix" level, and also
   removes the worry about handling such things as ``ernno`` when using
   IOTCLs. It is intended to be the normal means of using KBUS from C, and
   should also be useful when writing interfaces in other languages (which can
   typically call C).

The KBUS kernel module
~~~~~~~~~~~~~~~~~~~~~~
Using a kernel module means that:

* We can have a file interface, which makes KBUS easier to use.
* We can have a real expectation of our "daemon" not crashing (it is much
  easier to write a kernel module that is reliable, partly because there are
  so many constraints on how one does it, partly because one is executing in a
  different context, and partly because kernel mechanisms mediate the modules
  interaction with user space).
* We get to use relatively sophisticated and proven datastructures. Kernel
  modules are expected to use the provided mechanisms for handling lists
  and other datatypes. This avoids a lot of reinventing the wheel, or
  dependency on other libraries which might not be present.
* We benefit from kernel strategies on memory management, copying, etc.
* The kernel hides a lot of the complicated stuff (both at the top and bottom
  level) from us, so we can't do it wrong (well, it's much harder). For
  instance, ``read`` and ``write`` at the user level get filtered down into
  more predictable calls at the kernel module level.
* We stand to gain from the kernel handling such issues as multiple CPUs,
  threading and so on.
* With KBUS being in the kernel address space, we should benefit from less
  context switching.
* We can realistically expect to be told when a Ksock has closed, including if
  it has been closed because the process that opened it has crashed. This type
  of guarantee is much harder to attain in user space.

Messages
~~~~~~~~
In order to keep KBUS itself simple, KBUS does not say anything about the
message content. It restricts itself to defining the message header and the
mechanisms for managing messages.

    (We do have a nearly finished ASN.1 library for message data, and are
    looking at XMPP support, but these will be extras, not core KBUS. And,
    of course, one can use other mechanisms as one wishes.)

As indicated in the section on naming, the fields in the header aim to be easy
to understand, and we try to define *just* the fields we need.

Predictable delivery
--------------------
It is acceptable for a Listener to miss messages (although there are ways around
that), but a Replier shall never miss the Requests sent to it.

We also want to guarantee that each Request shall produce a Reply (even if it
is a Reply indicating failure to deliver the Request).

So:

* If a sender attempts to send a Request, but does not have room on its
  message queue for the (corresponding) Reply, then the message will not be
  sent, and the send will fail. At the "bare Unix" level, this means that the
  ``send`` IOCTL returns an error - the failure is immediate.

* If a replier cannot receive a particular message, because its queue is full,
  then the message will not be sent, and the send will fail with an error.
  Again, this failure is immediate.

* If a message has the ALL_OR_FAIL flag set, then a send will only succeed if
  the message could be added to all the (intended) recipient’s message
  queues (listeners as well).  Otherwise, ``send`` returns -EBUSY.

* If a message has the ALL_OR_WAIT flag set, then a send will only succeed if
  the message could be added to all the (intended) recipient’s message
  queues (listeners as well).  Otherwise ``send`` returns -EAGAIN.

  (The sender then needs to discard the message, or play the
  ``poll``/``select`` game to wait for the send to finish).

Note that we believe these last two mechanisms are primarily of use when
debugging systems.

Finally:

    """KBUS guarantees that each Request will (eventually) be matched by a
    consequent Reply (or Status) message, and only one such."""

If the replier can't give a Reply, KBUS will generate one (e.g.,
"``$.KBUS.Replier.Unbound``" or "``$.KBUS.ReplierGoneAway``").

Message order is the same for all
---------------------------------
It is important that if sender R sends message M(r) on KBUS device S, and
sender G sends message M(g) on the same KBUS, then all recipients of both
messages will see them in the same order.

    (Imagine sending instructions to a video decoder and a video recorder.
    Clearly both may need to receive the same instructions, and it is
    important to receive the instructions in the appropriate order.

    Similarly, consider a logging Listener. This too clearly wants to receive
    messages in the same order as the other Listeners. It especially wants to
    see Requests and Replies in the appropriate order.)

Since KBUS (the kernel module) has control over both ends of the transactions,
this is fairly simple to guarantee.

Isolation of buses
------------------
KBUS can provide multiple KBUS devices, but it does not allow communication
between them; they are totally isolated from each other.

Think of our notional R and G as metaphorical goldfish in a bowl.
They can only communicate via KBUS, and each bowl contains a single KBUS
device - in this instance, KBUS device 3:

.. image:: images/04_fish_in_bowl2.png
   :width: 5cm

.. :width:  370px
.. :height: 306px
.. :scale:  66

Two other fish, communicating via a different KBUS device, are in a different
metaphorical bowl, and thus cannot communicate with R and G.

.. image:: images/09_two_disjoint_bowls.png
   :width: 10.3cm

*(but, limpets...)*

.. Are we Pythonic yet?
   --------------------
   Well, it's an aim. For quick amusement, we can look at the Zen of Python and
   try to see how we're doing:
   
   ::
   
     >>> import this
     Beautiful is better than ugly.
   
   I can't really judge that, as I'm too close!
   
   ::
   
     Explicit is better than implicit.
     Simple is better than complex.
     Complex is better than complicated.
   
   Messaging is complex, we try not to make it complicated to do.
   
   We also try to implement only what we need, not "other stuff that might be
   useful".
   
   ::
   
     Flat is better than nested.
   
   I think KBUS is a "flat" system.
   
   ::
   
     Sparse is better than dense.
   
   OK... not sure how that applies.
   
   ::
   
     Readability counts.
   
   Again, you'll have to judge - I hope we're making a system that helps provide
   readable code.
   
   ::
   
     Special cases aren't special enough to break the rules.
     Although practicality beats purity.
   
   That's a difficult balance to judge - we're trying.
   
   ::
   
     Errors should never pass silently.
     Unless explicitly silenced.
   
   These definitely *are* KBUS aims.
   
   ::
   
     In the face of ambiguity, refuse the temptation to guess.
     There should be one-- and preferably only one --obvious way to do it.
     Although that way may not be obvious at first unless you're Dutch.
     Now is better than never.
     Although never is often better than *right* now.
   
   Hmm.
   
   ::
   
     If the implementation is hard to explain, it's a bad idea.
     If the implementation is easy to explain, it may be a good idea.
   
   These apply - I hope we're getting the balance right.
   
   ::
   
     Namespaces are one honking great idea -- let's do more of those!
   
   Erm...  KBUS appears to be noticeably lacking in the namespaces arena.

Why not use?
------------
What else could we have used?

There appear to be two main things we could have considered, DBUS and zeromq.

DBUS
~~~~
I've not spent an awful lot of time looking at DBUS, but my initial thoughts
are that:

* I don't understand it. Its documentation seems to show an over complex
  model, with no quick way in to understanding it, and a wish to split things
  into as many levels as possible.
* It is socket oriented (not a kernel module), which is probably the best
  approach for a user-space daemon, but
* It is in user-space, with the problems that can entail (including the
  difficulty of detecting if a replier has closed/crashed)
* Perhaps most importantly, it doesn't preserve message ordering across the
  bus. This is one of our key requirements.

    (My other note says "can't have more than one connection to the same dbus,
    and thus cannot get message ordering" - this sounds a key problem, if
    true.)

* I am told it is not all reliable...
* ...or even all implemented
* It is large.

But it is widely used (hmm) and has been around quite a while.

zeromq / 0mq
~~~~~~~~~~~~
zeromq (or 0mq) looks rather nice. It has good introductions, and seems to
have a clear idea of what its aims are, in particular aiming for speed
and scalability.

Its messages are minimalistic in strucure (a name and then content), which is
really rather nice. It is also very cross platform, both in the "implemented
on" sense, and in the "available for language X" sense.

It doesn't appear to b e aiming for the sort of "predicability" we're after
(or so I deduce from a scan of the documentation). And it is written in C++,
which rules it out for some prospective platforms.

However, this looks like one it would be fun to play with, and I definitely need to
learn more about it.

  (It's very tempting to think about it as a potential means of moving KBUS
  messages over networks, for instance.)

What else?
~~~~~~~~~~
I must have missed systems that I really should know about.

(Although note I'm ignoring many "enterprise space" systems, which often do
seek guarantees of delivery, but at the cost of being an enterprise system.)

.. note:: There is also the simple Linux/POSIX message system, check its name,
   but that doesn't address various of the issues. Explain...

----------------
Example messages
----------------
Some actual example message names, from Real Applications (lightly obfuscated,
perhaps).

...EXAMPLES TO BE INSERTED...

Maybe mention:

1. C++ bindings - I don't have the experience in C++ to write well designed
   bindings. Either use the C API, or talk directly on the file interface.
   If someone wants to contribute one...

2. JavaScript - we do have bindings for V8 (for a customer), but obviously
   each JavaScript implementation needs to have its own implementation. Talk
   to us if this is of interest...

3. Other languages - either the C API or the direct approach should serve as a
   starting point. Perhaps OO bindings can look at what I've done for Python.

-------
Limpets
-------

.. note:: I don't believe there will be room to get such into the slide
   show(!), but perhaps something should go into the paper? At least a mention
   that there is something to look at?



.. vim: set filetype=rst tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
